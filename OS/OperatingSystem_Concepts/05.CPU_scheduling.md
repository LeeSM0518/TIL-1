# 05. CPU 스케줄링

[![npm](https://img.shields.io/badge/version-2018.36-brightgreen.svg)]()



## 기본개념

**다중 프로그래밍**의 목적은 CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지게 하는 데 있습니다. 프로세스는 보통 어떤 입출력을 요청할 때 CPU를 사용하지 않고 대기합니다. 이러한 모든 대기 시간은 낭비이기 때문에 운영체제는 CPU를 대기 상태인 프로세스로부터 회수해 다른 프로세스에 할당합니다.

이러한 종류의 스케쥴링은 운영체제의 기본적인 기능입니다. CPU는 중요한 컴퓨터 자원 중 하나이므로 스케줄링은 운영체제 설계의 핵심이 됩니다.



###CPU-입출력 버스트 사이클(CPU-I/O Burst Cycle)

프로세스의 실행은 **CPU 실행(CPU 버스트)**과 **입출력 대기(입출력 버스트)**의 순환으로 구성됩니다. 프로세스는 이들 두 상태 사이를 교대로 왔다 갔다합니다.

CPU 버스트들의 지속 시간을 측정하였을 때 아래의 그림처럼 빈도수 곡선을 갖는 경향이 있습니다.

<img src="https://user-images.githubusercontent.com/42791260/45073826-ee986c00-b11b-11e8-98a8-086ad8b5d319.png" width="70%">

짧은 CPU 버스트가 많이 있으며 , 긴 CPU 버스트는 적습니다. 입출력 중심의 프로그램은 전형적으로 짧은 CPU 버스트를 많이 가질 것입니다. 이러한 분포는 적절한 CPU 스케줄링 알고리즘을 선택하는 데 매우 중요할 수 있습니다.



### CPU 스케줄러(CPU Scheduler)

CPU가 유휴 상태가 될 때마다, 운영체제는 **준비 완료 큐**에 있는 프로세스들 중에서 하나를 선택해 실행해야 합니다. 선택 절차는 **단기 스케줄러(또는, CPU 스케줄러)**에 의해 수행됩니다.

준비 완료 큐는 반드시 선입 선출(FIFO) 방식의 큐가 아니어도 되는 것에 유의해야 합니다. 준비 완료 큐는 선입 선출 큐, 우선순위 큐, 트리 또는 단순히 순서가 없는 연결 리스트로 구현할 수 있습니다. 준비 완료 큐에 있는 레코드들은 일반적으로 프로세들의 프로세스 제어 블록(PCB)입니다.



### 선점 스케줄링(Preemptive Scheduling)

CPU 스케줄링 결정은 다음의 네 가지 상황 하에서 발생할 수 있습니다.

* 한 프로세스가 실행 상테에서 대기 상태로 전환 될 때
  * 예를 들어, 입출력 요청이나 자식 프로세스가 종료되기를 기다리기 위해 wait를 호출할 때
* 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때
  * 예를 들어, 인터럽트가 발생할 때
* 프로세스가 대기 상태에서 준비 완료 상태로 전환 될 때
  * 예를 들어, 입출력의 종료 시
* 프로세스가 종료할 때



책 다 읽어보고 정리.... 뭔말인지 모르겠음....



###디스패처(Dispatcher)

**디스패처(dispatcher)**는 CPU 스케줄링 기능에 포함된 또 하나의 요소입니다. 디스패처는 CPU를 단기 스케줄러가 선택한 프로세스에게 할당 해주는 모듈이며 다음과 같은 작업을 포함합니다.

* 문맥 교환
* 사용자 모드로 전환
* 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동(jump)



디스패처는 모든 프로세스의 문맥 교환 시 호출 되므로, 가능한 빨리 수행되어야 합니다. 디스패처가 하나의 프로세스를 정지하고 다른 프로세스의 수행을 시작하는 데까지 소요되는 시간을 **디스패치 지연(dispatch latency)**이라고 합니다.



## 스케줄링 기준

 CPU 스케줄링 알고리즘들은 서로 다른 특성을 가지고 있습니다. 특정 상황에 필요한 알고리즘을 선택하려면, 우리는 알고리즘들의 특성들을 반드시 이해하고 있어야 합니다.

아래의 항목들은 CPU 스케줄링 알고리즘을 비교하기 위한 기준들입니다.

* **CPU 이용률(utilization):** 우리는 가능한 CPU를 최대한 바쁘게 유지하기를 원합니다. 실제 시스템에서는 40%에서 90%까지의 범위를 가져야 합니다.
* **처리량(throughput):** 단위 시간당 완료된 프로세스의 개수로 작업량을 측정 할 수 있습니다. 이것을 **처리량**이라고 합니다.
* **총처리 시간(turnaround time):** 프로세스의 입장에서 보면, 프로세스를 실행하는 데 소요된 시간이 중요한 기준될 수 있습니다. 프로세스의 제출 시간과 완료 시간의 간격을 총처리 시간이라고 합니다. 총처리 시간은 메모리에 들어가기 위해 기다리는 시간, 준비 완료 큐에서 대기한 시간, CPU에서 실행하는 시간, 그리고 입출력 시간을 합한 시간입니다.
* **대기 시간(waiting time):** 스케줄링 알고리즘은 단지 프로세스가 준비 완료 큐에서 대기하는 시간의 양에만 영향을 줍니다. **대기 시간은 준비 완료 큐에서 대기하면서 보낸 시간의 총 합**입니다.
* **응답 시간(response time):** 응답시간은 요구를 제출한 후 첫 번째 응답이 나올때까지의 시간입니다. 여기서 주의할 점은, 응답시간은 응답이 시작되는 데까지 걸리는 시간이지 그 응답을 출력하는 데 걸리는 시간이 아니라는 것입니다.



CPU 이용률과 처리량을 최대화하고 총처리 시간, 대기 시간, 응답 시간을 최소화하는 것이 바람직합니다. 대부분의 경우, 평균 츨정 시간을 최적화하려고 합니다. 그러나 최소값 또는 최대값을 최적하는 것이 바람직한 경우도 있습니다.



## 스케줄링 알고리즘





## 스레드 스케줄링



## 다중 처리기 스케줄링









